[![\\ \noindent\textbf{Formalization} \\  \\ We base our formalization on the memory model described in \textit{The Java\textsuperscript{TM} Language Specification} (JLS), Section 17.4~\cite{jls17}, which defines the possible behaviors of a program. \\  \\ \begin{definition}\label{def:action}[Action] \\ An \textbf{action} \( a \) is described by a tuple \( \langle k, v, u \rangle \), where: \\ \begin{itemize} \\     \item \( k \): The kind of action (e.g., read, write, lock, unlock, etc.). \\     \item \( v \): The variable or monitor involved in the action. \\     \item \( u \): The value associated with the action. \\ \end{itemize} \\ \end{definition} \\ \textit{Note: This definition adapts the action formalism from JLS 17.4.2~\cite{jls17} and omits the thread \( t \) component, as threads are not directly relevant to this work.} \\  \\ \begin{definition}\label{def:trace}[Program Trace] \\ A \textbf{program trace}, denoted as \( T \), is a global sequence of actions \( \langle a_1, a_2, \dots, a_n \rangle \) that represents the execution of a program during a single run. \end{definition} \\  \\  \\ \begin{definition}\label{def:readaction}[Read Action] \\ A \textbf{read action} occurs when a variable \( v \) is accessed, and a value \( u \) is transmitted from the main memory to the working memory of the thread executing the program. \\ \end{definition} \\  \\ \begin{definition}\label{def:bestanno}[Best Annotation Rule] \\ The type of the program element \( v \) at its declaration should be annotated as \codeid{@Nullable} if: \\ \[ \\ \exists \, a \in T, \ \text{Kind}(a) = \text{Read} \wedge \text{Variable}(a) = v \wedge \text{Value}(a) = \text{null}, \\ \] \\ where: \\ \begin{itemize} \\     \item \( \text{Kind}(a) \): The kind of action \( a \) (e.g., read, write, lock, etc.). \\     \item \( \text{Variable}(a) \): The program element \( v \) involved in action \( a \). \\     \item \( \text{Value}(a) \): The value associated with the action \( a \). \\ \end{itemize} \\ \end{definition} \\  \\ \begin{definition}\label{def:derefchain}[Dereference Chain] \\ The \textbf{dereference chain} \( \text{dereferences}() \) is a partial order over actions in the program trace \(T\)~\cite{jls17}. Formally, for actions \( r \) and \( a \), \( \text{dereferences}(r, a) \) holds if and only if: \\ \begin{itemize} \\     \item \( r \) is a read action that observes the reference of an object \( o \), and \\     \item \( a \) is a subsequent action that accesses \( o \), such as: \\     \begin{itemize} \\         \item reading or writing a field of \( o \) (e.g., \( o.field \)), \\         \item invoking a method on \( o \) (e.g., \( o.method() \)), or \\         \item accessing an array element of \( o \) (e.g., \( o[index] \)). \\     \end{itemize} \\ \end{itemize} \\ This partial order reflects the causal relationship between the actions \( r \) and \( a \), where \( r \) provides the reference required by \( a \). \\ \end{definition} \\  \\ \todo{Why is ``a'' referenced in the following definition?}  \\ \todo{EA: The variable \( a \) is included in this definition to represent the actions that access \( x \). It helps connect the causal relationship between a read action \( r \) that retrieves a reference and the action \( a \) that uses that reference to dereference \( x \). By defining \( \text{Dereference}(x) \) as the set of all dereferences of \( x \) in the program trace, we can clearly express conditions like ensuring that all references used in these dereferences are non-null, which is critical for defining null safety.} \\  \\ \begin{definition}\label{def:deref}[Dereference(x)] \\ For a program element \( x \), a \textbf{dereference(x)} is the set of all actions \( a \) in the program trace \(T\) that access \( x \). Formally: \\ \[ \\ \text{Dereference}(x) = \{ a \in T \mid \exists r \in T, \ \text{dereferences}(r, a) \wedge v(a) = x \}, \\ \] \\ \end{definition} \\  \\  \\ \begin{definition}\label{def:nullsafety}[Null Safety] \\ A program \( P \) is \textbf{null-safe} if for every program element \( x \) and for every action \( a \in \text{Dereference}(x) \), all read actions \( r \) in the dereference chain for \( a \) provide a non-\texttt{null} reference. Formally: \\ \[ \\ \forall x \in E_P, \ \forall a \in \text{Dereference}(x), \ \forall r \in T, \ \text{dereferences}(r, a) \implies \text{Value}(r) \neq \text{null}, \\ \] \\ where: \\ \begin{itemize} \\     \item \( E_P \): The set of all program elements in the program \( P \), including variables, fields, formal parameters, and method return values. \\ \end{itemize} \\ \end{definition} \\  \\  \\ \noindent\textbf{Proof Sketch for Null Safety:} \\  \\ We aim to prove that if a program is annotated according to the \textit{Best Annotation Rule} (Definition~\ref{def:bestanno}) and a sound nullability type checker reports no errors, then the program satisfies the definition of null safety (Definition~\ref{def:nullsafety}).  \\  \\ Assume the program is analyzed by a sound nullability type checker before execution. The proof proceeds by case analysis on the dereference chain for a program element \( x \): \\  \\ \begin{itemize} \\     \item \textbf{Case 1: At least one read action \( r \) in the dereference chain retrieves a \texttt{null} reference.}   \\     \begin{itemize} \\         \item Let \( a \) be an action accessing \( x \), and let \( r \) be a read action such that \( \text{dereferences}(r, a) \wedge v(a) = x \). \\         \item If \( \exists r \in T, \ \text{Value}(r) = \text{null} \), then by the \textit{Best Annotation Rule} (Definition~\ref{def:bestanno}), \( x \) must be annotated as \texttt{@Nullable}. \\         \item The nullability type checker ensures that \texttt{@Nullable} elements cannot be dereferenced without a null check. If there is a null check, the checker performs a local flow-sensitive refinement, treating the element as \texttt{@NonNull} within the scope of the null check. If \( a \) is not properly guarded, the checker raises a compilation error, preventing program execution. \\         \item Therefore, any unsafe dereference of \( x \) is statically rejected, and the program satisfies null safety. \\     \end{itemize} \\  \\     \item \textbf{Case 2: All read actions \( r \) in the dereference chain retrieve non-\texttt{null} references.}   \\     \begin{itemize} \\         \item If \( \forall r \in T, \ \text{dereferences}(r, a) \implies \text{Value}(r) \neq \text{null} \), then \( x \) is not annotated as \texttt{@Nullable}. \\         \item By Definition~\ref{def:nullsafety}, null safety is satisfied because no dereference chain retrieves a \texttt{null} value. \\     \end{itemize} \\ \end{itemize} \\  \\ \textit{Note: This proof assumes the presence of a sound nullability checker that rejects programs with unsafe dereferences.} \\  \\ ](https://latex.codecogs.com/svg.latex?%5C%5C%20%5Cnoindent%5Ctextbf%7BFormalization%7D%20%5C%5C%20%20%5C%5C%20We%20base%20our%20formalization%20on%20the%20memory%20model%20described%20in%20%5Ctextit%7BThe%20Java%5Ctextsuperscript%7BTM%7D%20Language%20Specification%7D%20(JLS)%2C%20Section%2017.4~%5Ccite%7Bjls17%7D%2C%20which%20defines%20the%20possible%20behaviors%20of%20a%20program.%20%5C%5C%20%20%5C%5C%20%5Cbegin%7Bdefinition%7D%5Clabel%7Bdef%3Aaction%7D%5BAction%5D%20%5C%5C%20An%20%5Ctextbf%7Baction%7D%20%5C(%20a%20%5C)%20is%20described%20by%20a%20tuple%20%5C(%20%5Clangle%20k%2C%20v%2C%20u%20%5Crangle%20%5C)%2C%20where%3A%20%5C%5C%20%5Cbegin%7Bitemize%7D%20%5C%5C%20%20%20%20%20%5Citem%20%5C(%20k%20%5C)%3A%20The%20kind%20of%20action%20(e.g.%2C%20read%2C%20write%2C%20lock%2C%20unlock%2C%20etc.).%20%5C%5C%20%20%20%20%20%5Citem%20%5C(%20v%20%5C)%3A%20The%20variable%20or%20monitor%20involved%20in%20the%20action.%20%5C%5C%20%20%20%20%20%5Citem%20%5C(%20u%20%5C)%3A%20The%20value%20associated%20with%20the%20action.%20%5C%5C%20%5Cend%7Bitemize%7D%20%5C%5C%20%5Cend%7Bdefinition%7D%20%5C%5C%20%5Ctextit%7BNote%3A%20This%20definition%20adapts%20the%20action%20formalism%20from%20JLS%2017.4.2~%5Ccite%7Bjls17%7D%20and%20omits%20the%20thread%20%5C(%20t%20%5C)%20component%2C%20as%20threads%20are%20not%20directly%20relevant%20to%20this%20work.%7D%20%5C%5C%20%20%5C%5C%20%5Cbegin%7Bdefinition%7D%5Clabel%7Bdef%3Atrace%7D%5BProgram%20Trace%5D%20%5C%5C%20A%20%5Ctextbf%7Bprogram%20trace%7D%2C%20denoted%20as%20%5C(%20T%20%5C)%2C%20is%20a%20global%20sequence%20of%20actions%20%5C(%20%5Clangle%20a_1%2C%20a_2%2C%20%5Cdots%2C%20a_n%20%5Crangle%20%5C)%20that%20represents%20the%20execution%20of%20a%20program%20during%20a%20single%20run.%20%5Cend%7Bdefinition%7D%20%5C%5C%20%20%5C%5C%20%20%5C%5C%20%5Cbegin%7Bdefinition%7D%5Clabel%7Bdef%3Areadaction%7D%5BRead%20Action%5D%20%5C%5C%20A%20%5Ctextbf%7Bread%20action%7D%20occurs%20when%20a%20variable%20%5C(%20v%20%5C)%20is%20accessed%2C%20and%20a%20value%20%5C(%20u%20%5C)%20is%20transmitted%20from%20the%20main%20memory%20to%20the%20working%20memory%20of%20the%20thread%20executing%20the%20program.%20%5C%5C%20%5Cend%7Bdefinition%7D%20%5C%5C%20%20%5C%5C%20%5Cbegin%7Bdefinition%7D%5Clabel%7Bdef%3Abestanno%7D%5BBest%20Annotation%20Rule%5D%20%5C%5C%20The%20type%20of%20the%20program%20element%20%5C(%20v%20%5C)%20at%20its%20declaration%20should%20be%20annotated%20as%20%5Ccodeid%7B%40Nullable%7D%20if%3A%20%5C%5C%20%5C%5B%20%5C%5C%20%5Cexists%20%5C%2C%20a%20%5Cin%20T%2C%20%5C%20%5Ctext%7BKind%7D(a)%20%3D%20%5Ctext%7BRead%7D%20%5Cwedge%20%5Ctext%7BVariable%7D(a)%20%3D%20v%20%5Cwedge%20%5Ctext%7BValue%7D(a)%20%3D%20%5Ctext%7Bnull%7D%2C%20%5C%5C%20%5C%5D%20%5C%5C%20where%3A%20%5C%5C%20%5Cbegin%7Bitemize%7D%20%5C%5C%20%20%20%20%20%5Citem%20%5C(%20%5Ctext%7BKind%7D(a)%20%5C)%3A%20The%20kind%20of%20action%20%5C(%20a%20%5C)%20(e.g.%2C%20read%2C%20write%2C%20lock%2C%20etc.).%20%5C%5C%20%20%20%20%20%5Citem%20%5C(%20%5Ctext%7BVariable%7D(a)%20%5C)%3A%20The%20program%20element%20%5C(%20v%20%5C)%20involved%20in%20action%20%5C(%20a%20%5C).%20%5C%5C%20%20%20%20%20%5Citem%20%5C(%20%5Ctext%7BValue%7D(a)%20%5C)%3A%20The%20value%20associated%20with%20the%20action%20%5C(%20a%20%5C).%20%5C%5C%20%5Cend%7Bitemize%7D%20%5C%5C%20%5Cend%7Bdefinition%7D%20%5C%5C%20%20%5C%5C%20%5Cbegin%7Bdefinition%7D%5Clabel%7Bdef%3Aderefchain%7D%5BDereference%20Chain%5D%20%5C%5C%20The%20%5Ctextbf%7Bdereference%20chain%7D%20%5C(%20%5Ctext%7Bdereferences%7D()%20%5C)%20is%20a%20partial%20order%20over%20actions%20in%20the%20program%20trace%20%5C(T%5C)~%5Ccite%7Bjls17%7D.%20Formally%2C%20for%20actions%20%5C(%20r%20%5C)%20and%20%5C(%20a%20%5C)%2C%20%5C(%20%5Ctext%7Bdereferences%7D(r%2C%20a)%20%5C)%20holds%20if%20and%20only%20if%3A%20%5C%5C%20%5Cbegin%7Bitemize%7D%20%5C%5C%20%20%20%20%20%5Citem%20%5C(%20r%20%5C)%20is%20a%20read%20action%20that%20observes%20the%20reference%20of%20an%20object%20%5C(%20o%20%5C)%2C%20and%20%5C%5C%20%20%20%20%20%5Citem%20%5C(%20a%20%5C)%20is%20a%20subsequent%20action%20that%20accesses%20%5C(%20o%20%5C)%2C%20such%20as%3A%20%5C%5C%20%20%20%20%20%5Cbegin%7Bitemize%7D%20%5C%5C%20%20%20%20%20%20%20%20%20%5Citem%20reading%20or%20writing%20a%20field%20of%20%5C(%20o%20%5C)%20(e.g.%2C%20%5C(%20o.field%20%5C))%2C%20%5C%5C%20%20%20%20%20%20%20%20%20%5Citem%20invoking%20a%20method%20on%20%5C(%20o%20%5C)%20(e.g.%2C%20%5C(%20o.method()%20%5C))%2C%20or%20%5C%5C%20%20%20%20%20%20%20%20%20%5Citem%20accessing%20an%20array%20element%20of%20%5C(%20o%20%5C)%20(e.g.%2C%20%5C(%20o%5Bindex%5D%20%5C)).%20%5C%5C%20%20%20%20%20%5Cend%7Bitemize%7D%20%5C%5C%20%5Cend%7Bitemize%7D%20%5C%5C%20This%20partial%20order%20reflects%20the%20causal%20relationship%20between%20the%20actions%20%5C(%20r%20%5C)%20and%20%5C(%20a%20%5C)%2C%20where%20%5C(%20r%20%5C)%20provides%20the%20reference%20required%20by%20%5C(%20a%20%5C).%20%5C%5C%20%5Cend%7Bdefinition%7D%20%5C%5C%20%20%5C%5C%20%5Ctodo%7BWhy%20is%20%60%60a''%20referenced%20in%20the%20following%20definition%3F%7D%20%20%5C%5C%20%5Ctodo%7BEA%3A%20The%20variable%20%5C(%20a%20%5C)%20is%20included%20in%20this%20definition%20to%20represent%20the%20actions%20that%20access%20%5C(%20x%20%5C).%20It%20helps%20connect%20the%20causal%20relationship%20between%20a%20read%20action%20%5C(%20r%20%5C)%20that%20retrieves%20a%20reference%20and%20the%20action%20%5C(%20a%20%5C)%20that%20uses%20that%20reference%20to%20dereference%20%5C(%20x%20%5C).%20By%20defining%20%5C(%20%5Ctext%7BDereference%7D(x)%20%5C)%20as%20the%20set%20of%20all%20dereferences%20of%20%5C(%20x%20%5C)%20in%20the%20program%20trace%2C%20we%20can%20clearly%20express%20conditions%20like%20ensuring%20that%20all%20references%20used%20in%20these%20dereferences%20are%20non-null%2C%20which%20is%20critical%20for%20defining%20null%20safety.%7D%20%5C%5C%20%20%5C%5C%20%5Cbegin%7Bdefinition%7D%5Clabel%7Bdef%3Aderef%7D%5BDereference(x)%5D%20%5C%5C%20For%20a%20program%20element%20%5C(%20x%20%5C)%2C%20a%20%5Ctextbf%7Bdereference(x)%7D%20is%20the%20set%20of%20all%20actions%20%5C(%20a%20%5C)%20in%20the%20program%20trace%20%5C(T%5C)%20that%20access%20%5C(%20x%20%5C).%20Formally%3A%20%5C%5C%20%5C%5B%20%5C%5C%20%5Ctext%7BDereference%7D(x)%20%3D%20%5C%7B%20a%20%5Cin%20T%20%5Cmid%20%5Cexists%20r%20%5Cin%20T%2C%20%5C%20%5Ctext%7Bdereferences%7D(r%2C%20a)%20%5Cwedge%20v(a)%20%3D%20x%20%5C%7D%2C%20%5C%5C%20%5C%5D%20%5C%5C%20%5Cend%7Bdefinition%7D%20%5C%5C%20%20%5C%5C%20%20%5C%5C%20%5Cbegin%7Bdefinition%7D%5Clabel%7Bdef%3Anullsafety%7D%5BNull%20Safety%5D%20%5C%5C%20A%20program%20%5C(%20P%20%5C)%20is%20%5Ctextbf%7Bnull-safe%7D%20if%20for%20every%20program%20element%20%5C(%20x%20%5C)%20and%20for%20every%20action%20%5C(%20a%20%5Cin%20%5Ctext%7BDereference%7D(x)%20%5C)%2C%20all%20read%20actions%20%5C(%20r%20%5C)%20in%20the%20dereference%20chain%20for%20%5C(%20a%20%5C)%20provide%20a%20non-%5Ctexttt%7Bnull%7D%20reference.%20Formally%3A%20%5C%5C%20%5C%5B%20%5C%5C%20%5Cforall%20x%20%5Cin%20E_P%2C%20%5C%20%5Cforall%20a%20%5Cin%20%5Ctext%7BDereference%7D(x)%2C%20%5C%20%5Cforall%20r%20%5Cin%20T%2C%20%5C%20%5Ctext%7Bdereferences%7D(r%2C%20a)%20%5Cimplies%20%5Ctext%7BValue%7D(r)%20%5Cneq%20%5Ctext%7Bnull%7D%2C%20%5C%5C%20%5C%5D%20%5C%5C%20where%3A%20%5C%5C%20%5Cbegin%7Bitemize%7D%20%5C%5C%20%20%20%20%20%5Citem%20%5C(%20E_P%20%5C)%3A%20The%20set%20of%20all%20program%20elements%20in%20the%20program%20%5C(%20P%20%5C)%2C%20including%20variables%2C%20fields%2C%20formal%20parameters%2C%20and%20method%20return%20values.%20%5C%5C%20%5Cend%7Bitemize%7D%20%5C%5C%20%5Cend%7Bdefinition%7D%20%5C%5C%20%20%5C%5C%20%20%5C%5C%20%5Cnoindent%5Ctextbf%7BProof%20Sketch%20for%20Null%20Safety%3A%7D%20%5C%5C%20%20%5C%5C%20We%20aim%20to%20prove%20that%20if%20a%20program%20is%20annotated%20according%20to%20the%20%5Ctextit%7BBest%20Annotation%20Rule%7D%20(Definition~%5Cref%7Bdef%3Abestanno%7D)%20and%20a%20sound%20nullability%20type%20checker%20reports%20no%20errors%2C%20then%20the%20program%20satisfies%20the%20definition%20of%20null%20safety%20(Definition~%5Cref%7Bdef%3Anullsafety%7D).%20%20%5C%5C%20%20%5C%5C%20Assume%20the%20program%20is%20analyzed%20by%20a%20sound%20nullability%20type%20checker%20before%20execution.%20The%20proof%20proceeds%20by%20case%20analysis%20on%20the%20dereference%20chain%20for%20a%20program%20element%20%5C(%20x%20%5C)%3A%20%5C%5C%20%20%5C%5C%20%5Cbegin%7Bitemize%7D%20%5C%5C%20%20%20%20%20%5Citem%20%5Ctextbf%7BCase%201%3A%20At%20least%20one%20read%20action%20%5C(%20r%20%5C)%20in%20the%20dereference%20chain%20retrieves%20a%20%5Ctexttt%7Bnull%7D%20reference.%7D%20%20%20%5C%5C%20%20%20%20%20%5Cbegin%7Bitemize%7D%20%5C%5C%20%20%20%20%20%20%20%20%20%5Citem%20Let%20%5C(%20a%20%5C)%20be%20an%20action%20accessing%20%5C(%20x%20%5C)%2C%20and%20let%20%5C(%20r%20%5C)%20be%20a%20read%20action%20such%20that%20%5C(%20%5Ctext%7Bdereferences%7D(r%2C%20a)%20%5Cwedge%20v(a)%20%3D%20x%20%5C).%20%5C%5C%20%20%20%20%20%20%20%20%20%5Citem%20If%20%5C(%20%5Cexists%20r%20%5Cin%20T%2C%20%5C%20%5Ctext%7BValue%7D(r)%20%3D%20%5Ctext%7Bnull%7D%20%5C)%2C%20then%20by%20the%20%5Ctextit%7BBest%20Annotation%20Rule%7D%20(Definition~%5Cref%7Bdef%3Abestanno%7D)%2C%20%5C(%20x%20%5C)%20must%20be%20annotated%20as%20%5Ctexttt%7B%40Nullable%7D.%20%5C%5C%20%20%20%20%20%20%20%20%20%5Citem%20The%20nullability%20type%20checker%20ensures%20that%20%5Ctexttt%7B%40Nullable%7D%20elements%20cannot%20be%20dereferenced%20without%20a%20null%20check.%20If%20there%20is%20a%20null%20check%2C%20the%20checker%20performs%20a%20local%20flow-sensitive%20refinement%2C%20treating%20the%20element%20as%20%5Ctexttt%7B%40NonNull%7D%20within%20the%20scope%20of%20the%20null%20check.%20If%20%5C(%20a%20%5C)%20is%20not%20properly%20guarded%2C%20the%20checker%20raises%20a%20compilation%20error%2C%20preventing%20program%20execution.%20%5C%5C%20%20%20%20%20%20%20%20%20%5Citem%20Therefore%2C%20any%20unsafe%20dereference%20of%20%5C(%20x%20%5C)%20is%20statically%20rejected%2C%20and%20the%20program%20satisfies%20null%20safety.%20%5C%5C%20%20%20%20%20%5Cend%7Bitemize%7D%20%5C%5C%20%20%5C%5C%20%20%20%20%20%5Citem%20%5Ctextbf%7BCase%202%3A%20All%20read%20actions%20%5C(%20r%20%5C)%20in%20the%20dereference%20chain%20retrieve%20non-%5Ctexttt%7Bnull%7D%20references.%7D%20%20%20%5C%5C%20%20%20%20%20%5Cbegin%7Bitemize%7D%20%5C%5C%20%20%20%20%20%20%20%20%20%5Citem%20If%20%5C(%20%5Cforall%20r%20%5Cin%20T%2C%20%5C%20%5Ctext%7Bdereferences%7D(r%2C%20a)%20%5Cimplies%20%5Ctext%7BValue%7D(r)%20%5Cneq%20%5Ctext%7Bnull%7D%20%5C)%2C%20then%20%5C(%20x%20%5C)%20is%20not%20annotated%20as%20%5Ctexttt%7B%40Nullable%7D.%20%5C%5C%20%20%20%20%20%20%20%20%20%5Citem%20By%20Definition~%5Cref%7Bdef%3Anullsafety%7D%2C%20null%20safety%20is%20satisfied%20because%20no%20dereference%20chain%20retrieves%20a%20%5Ctexttt%7Bnull%7D%20value.%20%5C%5C%20%20%20%20%20%5Cend%7Bitemize%7D%20%5C%5C%20%5Cend%7Bitemize%7D%20%5C%5C%20%20%5C%5C%20%5Ctextit%7BNote%3A%20This%20proof%20assumes%20the%20presence%20of%20a%20sound%20nullability%20checker%20that%20rejects%20programs%20with%20unsafe%20dereferences.%7D%20%5C%5C%20%20%5C%5C%20)](#_)
